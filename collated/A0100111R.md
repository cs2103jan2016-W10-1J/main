# A0100111R
###### \src\com\Main\Adder.java
``` java
import java.util.ArrayList;
import java.util.logging.Level;

public class Adder implements Commander{
	private Task newTask = new Task();
	ArrayList<Task> TaskList = new ArrayList<Task>();
	private static int taskIDMax = 0;
	

	public static int getTaskIDMax() {
		return taskIDMax;
	}

	public static void setTaskIDMax(int taskIDMax) {
		Adder.taskIDMax = taskIDMax;
	}

	public Adder(String[] parsedUserInput, ArrayList<Task> TaskList) {
		//The element of the string array will be in 
		//0.taskName, 1.location 2.date 3.start 4.end 5.tag 6.notification
		//int taskListSize = TaskList.size();
		this.TaskList = TaskList;
		try {
			newTask.setTask(parsedUserInput[0]);
			newTask.setLocation(parsedUserInput[1]);
			newTask.setDate(parsedUserInput[2]);
			newTask.setStart(parsedUserInput[3]);
			newTask.setEnd(parsedUserInput[4]);
			newTask.setTag(parsedUserInput[5]);
			newTask.setNotification(parsedUserInput[6]);
			newTask.setCalendar();
			newTask.setTaskID(taskIDMax+1);
			newTask.determineTaskType();
		} catch (NullPointerException e) {
			
			//e.printStackTrace();
			System.out.println("The Task is null. " + e.toString());
		}
	}

	@Override
	public String execute() {
		if (newTask.getTaskName().equals(" ") || newTask.getTaskName().equals(""))
			return "Task NOT added successfully due to empty Task title!";
		
		if (newTask.getDate().equals("invalid date")){
			return "Task NOT added successfully due to invalid date!";
		}
		
			TaskList.add(newTask);
			taskIDMax++;
			Displayer updateGUI = new Displayer(TaskList);
			updateGUI.execute();
			
			Processor.setLastCommanderInst(this);
			
			String taskType = newTask.getTaskType().toString();
			return "Task added successfully"+ "with type being: "+ taskType;

			//ProcessorLogger.log(Level.WARNING, "task not added successfully", e);
		
	}

	@Override
	public String undo() {
		ConverterToString taskConverter = new ConverterToString(newTask);
		String feedback = taskConverter.convert();
		
		if(TaskList.remove(newTask)){
			Processor.setLastCommanderInst(null);//Undoing add is designed for no chance of redoing.
			Displayer updateGUI = new Displayer(TaskList);
			updateGUI.execute();
			return "The following task is removed:"+System.lineSeparator()+feedback;		
		}
		else
			return "The undo to remove last task added is unsuccessful.";
	}

}
```
###### \src\com\Main\Deleter.java
``` java
public class Deleter implements Commander{
	private int taskID;
	private int taskIndex;
	private ArrayList<Task> TaskList;
	private Task taskDeleted = null;
	
	public Deleter(String[] parsedUserInput, ArrayList<Task> TaskList){
		//The first element in the array is the taskID to be deleted
		taskID = Integer.parseInt(parsedUserInput[0]);
		this.TaskList = TaskList;
	}
	@Override
	public String execute() {
		taskIndex = SearchTaskByID(taskID);
		if(taskIndex < 0){
			return "The taskID entered is invalid, please re-enter.";
		}else{
			taskDeleted = TaskList.remove(taskIndex);
			
			Displayer updateGUI = new Displayer(TaskList);
			updateGUI.execute();
			
			Processor.setLastCommanderInst(this);
			
			ConverterToString taskDeletedConversion = new ConverterToString(taskDeleted);
			String taskDeletedString = taskDeletedConversion.convert();
			String feedback = "Task deleted successfully:"+System.lineSeparator()+taskDeletedString;
			return feedback;
		}
	}	
/*		
		try{
		//assert(taskID >=0);
		//taskDeleted = TaskList.get(taskID-1).getTaskName() + " on " + TaskList.get(taskID-1).getDate();
			
		} catch (Exception e){
			//e.printStackTrace();
			return "Task deleted unsuccessfully";
		}
*/		

	
	private int SearchTaskByID(int DesiredTaskID) {
		for (int i = 0; i < TaskList.size(); i++){
			if(DesiredTaskID == TaskList.get(i).getTaskID()){
				return i;
			}
		}
		return -1; //-1 for the case of invalid TaskId which can't be found the match.
	}
	@Override
	public String undo() {
		ConverterToString taskConverter = new ConverterToString(taskDeleted);
		String feedback = taskConverter.convert();
		TaskList.add(taskDeleted);
		
		Displayer updateGUI = new Displayer(TaskList);
		updateGUI.execute();
		
		Processor.setLastCommanderInst(null);//Undoing delete is designed for no chance of redoing.
		return "The following task you deleted is added in again: "+System.lineSeparator()+feedback;
	}

}
```
###### \src\com\Main\Displayer.java
``` java
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;

import com.Main.Task.TASK_TYPE;

public class Displayer implements Commander{
	
	private boolean debug = false;
	
	private ArrayList<Task> TaskList;
	private static String displayParameter = "today";
	
	private static ArrayList<Task> eventList;
	private static ArrayList<Task> floatList;
	private static ArrayList<Task> deadlineList;
	private static ArrayList<Task> doneTaskList;
	private static ArrayList<Task> unDoneTaskList;
	
	/*
	 * First constructor is for situations when displayRequirement requires changes
	 * This constructor is also tailored for user command "Display displayParameter"
	 */
	public Displayer(String displayRequirement, ArrayList<Task> originalTaskList) {
		eventList = new ArrayList<Task>();
		floatList = new ArrayList<Task>();
		deadlineList = new ArrayList<Task>();
		doneTaskList  = new ArrayList<Task>();
		unDoneTaskList  = new ArrayList<Task>();
				
		displayParameter = displayRequirement;	
		this.TaskList = new ArrayList<Task>(originalTaskList);//Copy the original TaskList.
		
		this.getDoneTasks(originalTaskList);
		this.getEventList(unDoneTaskList);
		this.getFloatList(unDoneTaskList);
		this.getDeadlineList(unDoneTaskList);
	
		//debug
		//int x = Processor.getFloatList().size();
		//System.out.println(Integer.toString(x));
	}
	
	/*
	 * Second constructor is purely for the purpose of updating the GUI display.
	 * It is only used internally by other classes.
	 */
	public Displayer(ArrayList<Task> originalTaskList) {
		eventList = new ArrayList<Task>();
		floatList = new ArrayList<Task>();
		deadlineList = new ArrayList<Task>();
		doneTaskList  = new ArrayList<Task>();
		unDoneTaskList  = new ArrayList<Task>();
		
		this.TaskList = new ArrayList<Task>(originalTaskList);
		
		this.getDoneTasks(TaskList);
		this.getEventList(unDoneTaskList);
		this.getFloatList(unDoneTaskList);
		this.getDeadlineList(unDoneTaskList);
	
		if(debug){
			int x = Processor.getFloatList().size();
			System.out.println(Integer.toString(x));
		}
	}


	public String execute() {
		//display today/tomorrow/all/
		switch (displayParameter){
		case "today":
			getTodayTasks();
			break;
		case "tomorrow":
			getTmrTasks();
			break;
		//case "week":
		//	getThisWeekTasks();
		//	break;
		case "all":
			//Constructor has done the job.
			break;
			
		default:
			return "Unrecognized display parameter";
		}
		updateThreeLists();	
		
		return "Please refer to the right-hand side panel for display";
	}


	private void getTmrTasks(){
		Date date = new Date();		
		Calendar calendarInst = Calendar.getInstance(); 
		calendarInst.setTime(date); 
		calendarInst.add(Calendar.DATE, 1);
		date = calendarInst.getTime();
		
		SearcherByDate findTmrEvent = new SearcherByDate(date, eventList);
		eventList = findTmrEvent.executeforDisplayOnStartTime();
		
		SearcherByDate findTmrDeadline = new SearcherByDate(date, deadlineList);
		deadlineList = findTmrDeadline.executeforDisplayOnEndTime();
	}


	private void getTodayTasks() {
		Date date = new Date();
		SearcherByDate findTodayEvent = new SearcherByDate(date, eventList);
		eventList = findTodayEvent.executeforDisplayOnStartTime();
		
		SearcherByDate findTodayDeadline = new SearcherByDate(date, deadlineList);
		deadlineList = findTodayDeadline.executeforDisplayOnEndTime();
	}

/*
 * Complete the sort before update the Lists in the processor
 */
	private void updateThreeLists() {
		//Sort sortInst = new Sort(eventList);
		//eventList = sortInst.sortThis(); 
		if(debug){
		int x = Processor.getFloatList().size();
		System.out.println(Integer.toString(x));
		}
		Processor.setEventList(eventList);
		Processor.setFloatList(floatList);
		Processor.setDeadlineList(deadlineList);
		Processor.setDoneTaskList(doneTaskList);
	}

	
	private void getDoneTasks(ArrayList<Task> TaskList) {
		
		for (int i = 0; i < TaskList.size(); i++ ){
			Task taskInst = TaskList.get(i);
			if(taskInst.isTaskDone){
				doneTaskList.add(taskInst);
			}
			else{
				unDoneTaskList.add(taskInst);
			}
		}
	}
	

	public void getEventList(ArrayList<Task> TaskList){
		Task taskInst;
		for (int i = 0; i < TaskList.size(); i++){
			taskInst = TaskList.get(i);
			if ( taskInst.getTaskType() == TASK_TYPE.EVENT ){
				eventList.add(taskInst);
			}
		} 
	}
	public void getFloatList(ArrayList<Task> TaskList){
		Task taskInst;
		for (int i = 0; i < TaskList.size(); i++){
			taskInst = TaskList.get(i);
			if ( taskInst.getTaskType() == TASK_TYPE.FLOAT ){
				floatList.add(taskInst);
			}
		} 
	}
	public void getDeadlineList(ArrayList<Task> TaskList){
		Task taskInst;
		for (int i = 0; i < TaskList.size(); i++){
			taskInst = TaskList.get(i);
			if ( taskInst.getTaskType() == TASK_TYPE.DEADLINE ){
				deadlineList.add(taskInst);
			}
		} 
	}
	public static String getDisplayParameter() {
		return displayParameter;
	}




	@Override
	public String undo() {
		//String feedback = "Your last action is searching, which cannot be undone.";
		//return feedback;
		return "";
	}
	

}
```
###### \src\com\Main\Processor.java
``` java
	public static ArrayList<Task> getEventList() {
		return eventList;
	}

	public static void setEventList(ArrayList<Task> eventList) {
		Processor.eventList = eventList;
	}

	public static ArrayList<Task> getFloatList() {
		return floatList;
	}

	public static void setFloatList(ArrayList<Task> floatList) {
		Processor.floatList = floatList;
	}

	public static ArrayList<Task> getDeadlineList() {
		return deadlineList;
	}

	public static void setDeadlineList(ArrayList<Task> deadlineList) {
		Processor.deadlineList = deadlineList;
	}
	public static ArrayList<Task> getDoneTaskList() {
		return doneTaskList;
	}

	public static void setDoneTaskList(ArrayList<Task> doneTaskList) {
		Processor.doneTaskList = doneTaskList;
	}

	public static void setLastCommanderInst(Commander lastCommanderInst) {
		Processor.lastCommanderInst = lastCommanderInst;
	}

	public ArrayList<String> getMessageThread() {
		return messageThread;
	}
	
}
/*
	
	public TaskforUpdateFunction getUpdatedTask(){
		return UpdatedTask;
	}
	
	private void addTask(Parser parser){
		storage.readFile();
		ArrayList<Task> TaskList = storage.getTaskData();
		Task taskTobeAdded = parser.getCommand().getTask();
		assert(taskTobeAdded != null);
		
		try {
			TaskList.add(taskTobeAdded);
		} catch (Exception e) {
			//System.out.println("task not added successfuly" + e.getMessage());
			e.printStackTrace();
			ProcessorLogger.log(Level.WARNING, "task not added successfuly", e);
		}		
		storage.saveFile(TaskList);
	}
	

	private void deleteTask(Parser parser){
		int indexForDeletion = parser.getCommand().getDeleteRow();
		assert(indexForDeletion >= 0);	
		ArrayList<Task> TaskList = storage.getTaskData();
		try {
			TaskList.remove(indexForDeletion);
			ProcessorLogger.log(Level.INFO, "deletion done successfully.");
		} catch (IndexOutOfBoundsException e) {
			ProcessorLogger.log(Level.WARNING, "Task not deleted successfully due to invalid index", e);
			e.printStackTrace();
		}
		storage.saveFile(TaskList);
		ProcessorLogger.log(Level.INFO, "deletion saved.");
	}
		
	
	private TaskforUpdateFunction updateTask(Parser parser) {
		int IndexForUpdate = parser.getCommand().getUpdateRow() - 1;
		String TypeToUpdate = parser.getCommand().getUpdateType();
		String DetailToUpdate = parser.getCommand().getUpdateDetail();
		ArrayList<Task> TaskList = storage.getTaskData();
		//IndexForUpdate = -1;
		assert(IndexForUpdate >= 0);
		assert(TypeToUpdate != null);
		ProcessorLogger.log(Level.INFO, "gonna start to execute the update request");
		try {
			UpdatedTask.setOldTask(TaskList.get(IndexForUpdate));
			TaskList = executeUpdateRequest(IndexForUpdate, TypeToUpdate, DetailToUpdate, TaskList);
			
			UpdatedTask.setNewTask(TaskList.get(IndexForUpdate));
		} catch (ArrayIndexOutOfBoundsException e) {
			System.out.println("Invalid Task number detected, re-enter.");
			//e.printStackTrace();
			ProcessorLogger.log(Level.WARNING, "Updater error: invalid Task reference number", e);
		}
		storage.saveFile(TaskList);
		ProcessorLogger.log(Level.INFO, "update done and saved");

		//displayOneTask(IndexForUpdate, TaskList);
		
		return UpdatedTask;
	}

	private String displayOneTask(int indexForUpdate, ArrayList<Task> taskList) {
		StringBuilder TaskToShow = new StringBuilder();
		TaskToShow.append(String.format(DISPLAY_TASK_TITLE_MESSAGE, taskList.get(indexForUpdate).getTaskName()));
		TaskToShow.append(String.format(DISPLAY_TASK_DATE_MESSAGE, taskList.get(indexForUpdate).getDate()));
		TaskToShow.append(String.format(DISPLAY_TASK_LOCATION_MESSAGE, taskList.get(indexForUpdate).getLocation()));
		TaskToShow.append(String.format(DISPLAY_TASK_START_MESSAGE, taskList.get(indexForUpdate).getStart()));
		TaskToShow.append(String.format(DISPLAY_TASK_END_MESSAGE, taskList.get(indexForUpdate).getEnd()));
		TaskToShow.append(String.format(DISPLAY_TASK_TAG_MESSAGE, taskList.get(indexForUpdate).getTag()));
		TaskToShow.append(String.format(DISPLAY_TASK_NOTIFICATION_MESSAGE, taskList.get(indexForUpdate).getNotification()));
						
		return TaskToShow.toString();
		
	}
	
	private static final String DISPLAY_TASK_TITLE_MESSAGE = "Title:%1$s\r\n";
	private static final String DISPLAY_TASK_DATE_MESSAGE = "Date:%1$s\r\n";
	private static final String DISPLAY_TASK_LOCATION_MESSAGE = "Location:%1$s\r\n";
	private static final String DISPLAY_TASK_START_MESSAGE = "Start:%1$s\r\n";
	private static final String DISPLAY_TASK_END_MESSAGE = "End:%1$s\r\n";
	private static final String DISPLAY_TASK_TAG_MESSAGE = "Tag:%1$s\r\n";
	private static final String DISPLAY_TASK_NOTIFICATION_MESSAGE = "Notification:%1$s\r\n";
}
	

	*/
```
###### \src\com\Main\SearcherForFreeTimeSlot.java
``` java
	@Override
	public String undo() {
		//String feedback = "Your last action is searching, which cannot be undone.";
		//return feedback;
		return "";
	}

}
```
###### \src\com\Main\Task.java
``` java
public class Task {

	private boolean debug = false;

	enum TASK_TYPE{
		EVENT, FLOAT, DEADLINE;
	}
	private String taskName = "";
	private String date = ""; //"MM dd yyyy"
	private String location = "";
	private String start = "";//"HHmm" format
	private String end = "";//"HHmm" format
	private String tag = "";
	private String notification = "";
	boolean isTaskDone = false;

	private GregorianCalendar startCal;//= new GregorianCalendar();
	private GregorianCalendar endCal; //= new GregorianCalendar();

	private int taskID;
	private TASK_TYPE taskType;


	public GregorianCalendar getEndCal() {
		return endCal;
	}

	public void setEndCal(GregorianCalendar endCal) {
		this.endCal = endCal;
	}

	public void setStartCal(GregorianCalendar startCal) {
		this.startCal = startCal;
	}

	public TASK_TYPE getTaskType() {
		return taskType;
	}

	public void setTaskType(TASK_TYPE taskType) {
		this.taskType = taskType;
	}

	public void setTaskID(int taskID) {
		this.taskID = taskID;
	}

	public int getTaskID() {
		return taskID;
	}
	public void determineTaskType(){

		if ( date.equals(" ") || date.equals("") || date == null){
			this.setTaskType(TASK_TYPE.FLOAT);
			return;
		}else {
			if ( !start.equals(" ") && !end.equals(" ") ){ // have date start-time end-time
				this.setTaskType(TASK_TYPE.EVENT);
				return;
			}else
				if ( (start.equals(" ") || start.equals("")|| start == null ) && (!end.equals(" ") && !end.equals(""))){ //only no start time
					this.setTaskType(TASK_TYPE.DEADLINE);
					return;
				}else{
					this.setTaskType(TASK_TYPE.FLOAT); // rest of the cases
					return;
				} 
		}

	}

	/*
	 * http://stackoverflow.com/questions/4216745/java-string-to-date-conversion
	 */
	public void setCalendar(){
		if( debug)
			System. out.println( "see what inside the dateString: "+"<"+this.getDate()+ ">");

		if ( date.equals(" ") || date.equals("") || date == null){
			
			if( debug){
				System.out.println( "No date, is the rest of Code executed? ");
			}
			return;
		}

		DateFormat formatter = new SimpleDateFormat( "MM dd yyyy HHmm");
		Date date = new Date();
		if ( !this.getStart().equals(" ")){
			try {
				date = formatter.parse( this.getDate() + " " + this.getStart()); // String to Date object
			} catch (ParseException e) {
				System. out.println( "Start date object is not successfully parsed from its string counterpart:" + e.getMessage());
			}
			startCal = new GregorianCalendar();
			startCal.setTime( date);
		}

		if ( !this.getEnd().equals(" ")){
			try {
				date = formatter.parse( this.getDate() + " " + this.getEnd()); // String to Date object
			} catch (ParseException e) {
				System. out.println( "End date object is not successfully parsed from its string counterpart" + e.getMessage());
			}
			endCal = new GregorianCalendar();
			endCal.setTime( date);
		}

		/*
		 *        //re-format the date string according to actual Gregorian Date
       DateFormat dateFormatter = new SimpleDateFormat("MM dd yyyy ");
       Date dateInst = new Date();
       try {
            dateInst = dateFormatter.parse(this.getDate());
       } catch (ParseException e1) {
            System.out.println("in Task.java, fail to re-format the date string according to actual Gregorian Date");
       }
        int month = dateInst.getMonth()+1;
        int day = dateInst.getDate();
        int year = dateInst.getYear()+1900;
       String monthStr = Integer.toString(month);
       String dayStr = Integer.toString(day);
       String yearStr = Integer.toString(year);
       date = monthStr +" "+ dayStr + " "+ yearStr;
		 */      
	}



	public void updateNonStringField(){
		this.setCalendar();
		this.determineTaskType();
	}

	public GregorianCalendar getStartCal() {
		return startCal;
	}

	public Task(){
	}

	public String getTaskName() {
		return taskName;
	}

	public String getLocation() {
		return location;
	}
	public String getDate(){
		return date;
	}

	public String getStart() {
		return start;
	}

	public String getEnd() {
		return end;
	}

	public String getTag() {
		return tag;
	}

	public String getNotification() {
		return notification;
	}

	public boolean isTaskDone(){
		return isTaskDone;
	}

	public void setTask(String taskName) {
		this.taskName = taskName;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public void setDate(String date) {
		this.date = date;
	}

	public void setStart(String start) {
		this.start = start;
	}

	public void setEnd(String end) {
		this.end = end;
	}

	public void setTag(String tag) {
		this.tag = tag;
	}

	public void setNotification(String notification) {
		this.notification = notification;
	}

```
###### \src\com\Main\Updater.java
``` java
			
			updatedTask.determineTaskType();
			Processor.setLastCommanderInst(this);
			
			ConverterToString taskUpdatedConversion = new ConverterToString(updatedTask);
			String feedBackBody = taskUpdatedConversion.convert();
			String feedBackTitle = "Task "+Integer.toString(taskIDinput)+"'s "+sectionToUpdate+" was updated successfully FROM "+oldDetail+" to "+":"+detailToUpdate+":"+System.lineSeparator();

			Displayer updateGUI = new Displayer(TaskList);
			updateGUI.execute();
			
			String taskType = updatedTask.getTaskType().toString();
			return feedBackTitle+System.lineSeparator()+"The updated task now:"+System.lineSeparator()+feedBackBody+System.lineSeparator()+taskType;
			
		}
	}

```
###### \src\com\Main\Updater.java
``` java
	@Override
	public String undo() {
		String[] inputForUndo = new String[3];
		int sameIndex = this.indexToUpdate + 1;
		//current this.indexToUpdate is the index of array, +1 to change it back to user's form.
		inputForUndo[0] = Integer.toString(sameIndex);
		inputForUndo[1] = this.sectionToUpdate;
		inputForUndo[2] = this.oldDetail;
		Updater undoUpdate = new Updater(inputForUndo, this.TaskList);
		
		Displayer updateGUI = new Displayer(TaskList);
		updateGUI.execute();
		
		return "The following is re-updated as undo: "+ System.lineSeparator()+undoUpdate.execute();
	}

	
	
	private int SearchTaskByID(int DesiredTaskID) {
		for (int i = 0; i < TaskList.size(); i++){
			if(DesiredTaskID == TaskList.get(i).getTaskID()){
				return i;
			}
		}
		return -1; //-1 for the case of invalid TaskId which can't be found the match.
	}
}
```
